VECTOR_SIZE = 620;
FLASH_SIZE = 256K;
RAM_SIZE = 32K;

STACK_SIZE = @DRINLI_STACK_SIZE@;

MEMORY
{
    VECS  (RX)  : ORIGIN = 0x00000000, LENGTH = VECTOR_SIZE
    FLASH (RX)  : ORIGIN = 0x0000026d, LENGTH = FLASH_SIZE
    RAM   (RWX) : ORIGIN = 0x20000000, LENGTH = RAM_SIZE
}

SECTIONS
{
    .vector_table : ALIGN(4) {
        KEEP(*(.initial_stack))
        KEEP(*(.interrupt_vectors))
    } > VECS

    .text : ALIGN(4) {
        *(.text .text.* .gnu.linkonce.t.*)
        *(.rodata .rodata.* .gnu.linkonce.r.*)

        . = ALIGN(4);
        _preinit_array_start = .;
        KEEP(*(.preinit_array))
        _preinit_array_end = .;

        . = ALIGN(4);
        _init_array_start = .;
        KEEP (*(SORT(.init_array.*)))
        KEEP (*(.init_array))
        _init_array_end = .;
    } > FLASH

    .data : AT(ADDR(.text) + SIZEOF(.text)) {
        _data_start = .;
        *(.data .data.*)
        . = ALIGN(4);
        _data_end = .;
    } > RAM

    _data_load_point = LOADADDR(.data);

    .bss (NOLOAD) : {
        . = ALIGN(4);
        _bss_start = .;
        *(.bss .bss.*)
        . = ALIGN(4);
        _bss_end = .;
    } > RAM

    .stack (NOLOAD) : ALIGN(8) {
        . = . + STACK_SIZE;
        _initial_stack_end = .;
    } > RAM

    . = ALIGN(4);
    _heap_start = .;
    PROVIDE(end = .);
    . = ADDR(.data) + RAM_SIZE;
    _head_end = .;
    _heap_size = _head_end - _heap_start;

    /DISCARD/ : {
        *(.init)
        *(.fini)
        *(.fini_array)
        *(.fini_array.*)
        *(.dtors)
        *(dtors.*)
    }
}
